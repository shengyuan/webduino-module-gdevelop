!function (e, t) { "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : "object" == typeof exports ? exports = t() : e.Paho = t() }(this, function () { return function (e) { var t, s = e.localStorage || (t = {}, { setItem: function (e, s) { t[e] = s }, getItem: function (e) { return t[e] }, removeItem: function (e) { delete t[e] } }), n = { CONNECT: 1, CONNACK: 2, PUBLISH: 3, PUBACK: 4, PUBREC: 5, PUBREL: 6, PUBCOMP: 7, SUBSCRIBE: 8, SUBACK: 9, UNSUBSCRIBE: 10, UNSUBACK: 11, PINGREQ: 12, PINGRESP: 13, DISCONNECT: 14 }, i = function (e, t) { for (var s in e) if (e.hasOwnProperty(s)) { if (!t.hasOwnProperty(s)) { var n = "Unknown property, " + s + ". Valid properties are:"; for (var i in t) t.hasOwnProperty(i) && (n = n + " " + i); throw new Error(n) } if (typeof e[s] !== t[s]) throw new Error(a(r.INVALID_TYPE, [typeof e[s], s])) } }, o = function (e, t) { return function () { return e.apply(t, arguments) } }, r = { OK: { code: 0, text: "AMQJSC0000I OK." }, CONNECT_TIMEOUT: { code: 1, text: "AMQJSC0001E Connect timed out." }, SUBSCRIBE_TIMEOUT: { code: 2, text: "AMQJS0002E Subscribe timed out." }, UNSUBSCRIBE_TIMEOUT: { code: 3, text: "AMQJS0003E Unsubscribe timed out." }, PING_TIMEOUT: { code: 4, text: "AMQJS0004E Ping timed out." }, INTERNAL_ERROR: { code: 5, text: "AMQJS0005E Internal error. Error Message: {0}, Stack trace: {1}" }, CONNACK_RETURNCODE: { code: 6, text: "AMQJS0006E Bad Connack return code:{0} {1}." }, SOCKET_ERROR: { code: 7, text: "AMQJS0007E Socket error:{0}." }, SOCKET_CLOSE: { code: 8, text: "AMQJS0008I Socket closed." }, MALFORMED_UTF: { code: 9, text: "AMQJS0009E Malformed UTF data:{0} {1} {2}." }, UNSUPPORTED: { code: 10, text: "AMQJS0010E {0} is not supported by this browser." }, INVALID_STATE: { code: 11, text: "AMQJS0011E Invalid state {0}." }, INVALID_TYPE: { code: 12, text: "AMQJS0012E Invalid type {0} for {1}." }, INVALID_ARGUMENT: { code: 13, text: "AMQJS0013E Invalid argument {0} for {1}." }, UNSUPPORTED_OPERATION: { code: 14, text: "AMQJS0014E Unsupported operation." }, INVALID_STORED_DATA: { code: 15, text: "AMQJS0015E Invalid data in local storage key={0} value={1}." }, INVALID_MQTT_MESSAGE_TYPE: { code: 16, text: "AMQJS0016E Invalid MQTT message type {0}." }, MALFORMED_UNICODE: { code: 17, text: "AMQJS0017E Malformed Unicode string:{0} {1}." }, BUFFER_FULL: { code: 18, text: "AMQJS0018E Message buffer is full, maximum buffer size: {0}." } }, c = { 0: "Connection Accepted", 1: "Connection Refused: unacceptable protocol version", 2: "Connection Refused: identifier rejected", 3: "Connection Refused: server unavailable", 4: "Connection Refused: bad user name or password", 5: "Connection Refused: not authorized" }, a = function (e, t) { var s = e.text; if (t) for (var n, i, o = 0; o < t.length; o++)if (n = "{" + o + "}", (i = s.indexOf(n)) > 0) { var r = s.substring(0, i), c = s.substring(i + n.length); s = r + t[o] + c } return s }, h = [0, 6, 77, 81, 73, 115, 100, 112, 3], u = [0, 4, 77, 81, 84, 84, 4], d = function (e, t) { this.type = e; for (var s in t) t.hasOwnProperty(s) && (this[s] = t[s]) }; function l(e, t) { var s, i = t, o = e[t], r = o >> 4, c = o &= 15; t += 1; var a = 0, h = 1; do { if (t == e.length) return [null, i]; a += (127 & (s = e[t++])) * h, h *= 128 } while (0 != (128 & s)); var u = t + a; if (u > e.length) return [null, i]; var l = new d(r); switch (r) { case n.CONNACK: 1 & e[t++] && (l.sessionPresent = !0), l.returnCode = e[t++]; break; case n.PUBLISH: var f = c >> 1 & 3, _ = g(e, t), p = E(e, t += 2, _); t += _, f > 0 && (l.messageIdentifier = g(e, t), t += 2); var I = new w(e.subarray(t, u)); 1 == (1 & c) && (I.retained = !0), 8 == (8 & c) && (I.duplicate = !0), I.qos = f, I.destinationName = p, l.payloadMessage = I; break; case n.PUBACK: case n.PUBREC: case n.PUBREL: case n.PUBCOMP: case n.UNSUBACK: l.messageIdentifier = g(e, t); break; case n.SUBACK: l.messageIdentifier = g(e, t), t += 2, l.returnCode = e.subarray(t, u) }return [l, u] } function f(e, t, s) { return t[s++] = e >> 8, t[s++] = e % 256, s } function _(e, t, s, n) { return I(e, s, n = f(t, s, n)), n + t } function g(e, t) { return 256 * e[t] + e[t + 1] } function p(e) { for (var t = 0, s = 0; s < e.length; s++) { var n = e.charCodeAt(s); n > 2047 ? (55296 <= n && n <= 56319 && (s++ , t++), t += 3) : n > 127 ? t += 2 : t++ } return t } function I(e, t, s) { for (var n = s, i = 0; i < e.length; i++) { var o = e.charCodeAt(i); if (55296 <= o && o <= 56319) { var c = e.charCodeAt(++i); if (isNaN(c)) throw new Error(a(r.MALFORMED_UNICODE, [o, c])); o = c - 56320 + (o - 55296 << 10) + 65536 } o <= 127 ? t[n++] = o : o <= 2047 ? (t[n++] = o >> 6 & 31 | 192, t[n++] = 63 & o | 128) : o <= 65535 ? (t[n++] = o >> 12 & 15 | 224, t[n++] = o >> 6 & 63 | 128, t[n++] = 63 & o | 128) : (t[n++] = o >> 18 & 7 | 240, t[n++] = o >> 12 & 63 | 128, t[n++] = o >> 6 & 63 | 128, t[n++] = 63 & o | 128) } return t } function E(e, t, s) { for (var n, i = "", o = t; o < t + s;) { var c = e[o++]; if (c < 128) n = c; else { var h = e[o++] - 128; if (h < 0) throw new Error(a(r.MALFORMED_UTF, [c.toString(16), h.toString(16), ""])); if (c < 224) n = 64 * (c - 192) + h; else { var u = e[o++] - 128; if (u < 0) throw new Error(a(r.MALFORMED_UTF, [c.toString(16), h.toString(16), u.toString(16)])); if (c < 240) n = 4096 * (c - 224) + 64 * h + u; else { var d = e[o++] - 128; if (d < 0) throw new Error(a(r.MALFORMED_UTF, [c.toString(16), h.toString(16), u.toString(16), d.toString(16)])); if (!(c < 248)) throw new Error(a(r.MALFORMED_UTF, [c.toString(16), h.toString(16), u.toString(16), d.toString(16)])); n = 262144 * (c - 240) + 4096 * h + 64 * u + d } } } n > 65535 && (n -= 65536, i += String.fromCharCode(55296 + (n >> 10)), n = 56320 + (1023 & n)), i += String.fromCharCode(n) } return i } d.prototype.encode = function () { var e, t = (15 & this.type) << 4, s = 0, i = [], o = 0; switch (void 0 !== this.messageIdentifier && (s += 2), this.type) { case n.CONNECT: switch (this.mqttVersion) { case 3: s += h.length + 3; break; case 4: s += u.length + 3 }s += p(this.clientId) + 2, void 0 !== this.willMessage && (s += p(this.willMessage.destinationName) + 2, (e = this.willMessage.payloadBytes) instanceof Uint8Array || (e = new Uint8Array(c)), s += e.byteLength + 2), void 0 !== this.userName && (s += p(this.userName) + 2), void 0 !== this.password && (s += p(this.password) + 2); break; case n.SUBSCRIBE: t |= 2; for (var r = 0; r < this.topics.length; r++)i[r] = p(this.topics[r]), s += i[r] + 2; s += this.requestedQos.length; break; case n.UNSUBSCRIBE: t |= 2; for (r = 0; r < this.topics.length; r++)i[r] = p(this.topics[r]), s += i[r] + 2; break; case n.PUBREL: t |= 2; break; case n.PUBLISH: this.payloadMessage.duplicate && (t |= 8), t = t |= this.payloadMessage.qos << 1, this.payloadMessage.retained && (t |= 1), s += (o = p(this.payloadMessage.destinationName)) + 2; var c = this.payloadMessage.payloadBytes; s += c.byteLength, c instanceof ArrayBuffer ? c = new Uint8Array(c) : c instanceof Uint8Array || (c = new Uint8Array(c.buffer)); break; case n.DISCONNECT: }var a = function (e) { var t = new Array(1), s = 0; do { var n = e % 128; (e >>= 7) > 0 && (n |= 128), t[s++] = n } while (e > 0 && s < 4); return t }(s), d = a.length + 1, l = new ArrayBuffer(s + d), g = new Uint8Array(l); if (g[0] = t, g.set(a, 1), this.type == n.PUBLISH) d = _(this.payloadMessage.destinationName, o, g, d); else if (this.type == n.CONNECT) { switch (this.mqttVersion) { case 3: g.set(h, d), d += h.length; break; case 4: g.set(u, d), d += u.length }var I = 0; this.cleanSession && (I = 2), void 0 !== this.willMessage && (I |= 4, I |= this.willMessage.qos << 3, this.willMessage.retained && (I |= 32)), void 0 !== this.userName && (I |= 128), void 0 !== this.password && (I |= 64), g[d++] = I, d = f(this.keepAliveInterval, g, d) } switch (void 0 !== this.messageIdentifier && (d = f(this.messageIdentifier, g, d)), this.type) { case n.CONNECT: d = _(this.clientId, p(this.clientId), g, d), void 0 !== this.willMessage && (d = _(this.willMessage.destinationName, p(this.willMessage.destinationName), g, d), d = f(e.byteLength, g, d), g.set(e, d), d += e.byteLength), void 0 !== this.userName && (d = _(this.userName, p(this.userName), g, d)), void 0 !== this.password && (d = _(this.password, p(this.password), g, d)); break; case n.PUBLISH: g.set(c, d); break; case n.SUBSCRIBE: for (r = 0; r < this.topics.length; r++)d = _(this.topics[r], i[r], g, d), g[d++] = this.requestedQos[r]; break; case n.UNSUBSCRIBE: for (r = 0; r < this.topics.length; r++)d = _(this.topics[r], i[r], g, d) }return l }; var v = function (e, t) { this._client = e, this._keepAliveInterval = 1e3 * t, this.isReset = !1; var s = new d(n.PINGREQ).encode(), i = function (e) { return function () { return o.apply(e) } }, o = function () { this.isReset ? (this.isReset = !1, this._client._trace("Pinger.doPing", "send PINGREQ"), this._client.socket.send(s), this.timeout = setTimeout(i(this), this._keepAliveInterval)) : (this._client._trace("Pinger.doPing", "Timed out"), this._client._disconnected(r.PING_TIMEOUT.code, a(r.PING_TIMEOUT))) }; this.reset = function () { this.isReset = !0, clearTimeout(this.timeout), this._keepAliveInterval > 0 && (this.timeout = setTimeout(i(this), this._keepAliveInterval)) }, this.cancel = function () { clearTimeout(this.timeout) } }, m = function (e, t, s, n) { t || (t = 30); var i, o, r; this.timeout = setTimeout((i = s, o = e, r = n, function () { return i.apply(o, r) }), 1e3 * t), this.cancel = function () { clearTimeout(this.timeout) } }, y = function (t, n, i, o, c) { if (!("WebSocket" in e && null !== e.WebSocket)) throw new Error(a(r.UNSUPPORTED, ["WebSocket"])); if (!("ArrayBuffer" in e && null !== e.ArrayBuffer)) throw new Error(a(r.UNSUPPORTED, ["ArrayBuffer"])); this._trace("Paho.Client", t, n, i, o, c), this.host = n, this.port = i, this.path = o, this.uri = t, this.clientId = c, this._wsuri = null, this._localKey = n + ":" + i + ("/mqtt" != o ? ":" + o : "") + ":" + c + ":", this._msg_queue = [], this._buffered_msg_queue = [], this._sentMessages = {}, this._receivedMessages = {}, this._notify_msg_sent = {}, this._message_identifier = 1, this._sequence = 0; for (var h in s) 0 !== h.indexOf("Sent:" + this._localKey) && 0 !== h.indexOf("Received:" + this._localKey) || this.restore(h) }; y.prototype.host = null, y.prototype.port = null, y.prototype.path = null, y.prototype.uri = null, y.prototype.clientId = null, y.prototype.socket = null, y.prototype.connected = !1, y.prototype.maxMessageIdentifier = 65536, y.prototype.connectOptions = null, y.prototype.hostIndex = null, y.prototype.onConnected = null, y.prototype.onConnectionLost = null, y.prototype.onMessageDelivered = null, y.prototype.onMessageArrived = null, y.prototype.traceFunction = null, y.prototype._msg_queue = null, y.prototype._buffered_msg_queue = null, y.prototype._connectTimeout = null, y.prototype.sendPinger = null, y.prototype.receivePinger = null, y.prototype._reconnectInterval = 1, y.prototype._reconnecting = !1, y.prototype._reconnectTimeout = null, y.prototype.disconnectedPublishing = !1, y.prototype.disconnectedBufferSize = 5e3, y.prototype.receiveBuffer = null, y.prototype._traceBuffer = null, y.prototype._MAX_TRACE_ENTRIES = 100, y.prototype.connect = function (e) { var t = this._traceMask(e, "password"); if (this._trace("Client.connect", t, this.socket, this.connected), this.connected) throw new Error(a(r.INVALID_STATE, ["already connected"])); if (this.socket) throw new Error(a(r.INVALID_STATE, ["already connected"])); this._reconnecting && (this._reconnectTimeout.cancel(), this._reconnectTimeout = null, this._reconnecting = !1), this.connectOptions = e, this._reconnectInterval = 1, this._reconnecting = !1, e.uris ? (this.hostIndex = 0, this._doConnect(e.uris[0])) : this._doConnect(this.uri) }, y.prototype.subscribe = function (e, t) { if (this._trace("Client.subscribe", e, t), !this.connected) throw new Error(a(r.INVALID_STATE, ["not connected"])); var s = new d(n.SUBSCRIBE); s.topics = e.constructor === Array ? e : [e], void 0 === t.qos && (t.qos = 0), s.requestedQos = []; for (var i = 0; i < s.topics.length; i++)s.requestedQos[i] = t.qos; t.onSuccess && (s.onSuccess = function (e) { t.onSuccess({ invocationContext: t.invocationContext, grantedQos: e }) }), t.onFailure && (s.onFailure = function (e) { t.onFailure({ invocationContext: t.invocationContext, errorCode: e, errorMessage: a(e) }) }), t.timeout && (s.timeOut = new m(this, t.timeout, t.onFailure, [{ invocationContext: t.invocationContext, errorCode: r.SUBSCRIBE_TIMEOUT.code, errorMessage: a(r.SUBSCRIBE_TIMEOUT) }])), this._requires_ack(s), this._schedule_message(s) }, y.prototype.unsubscribe = function (e, t) { if (this._trace("Client.unsubscribe", e, t), !this.connected) throw new Error(a(r.INVALID_STATE, ["not connected"])); var s = new d(n.UNSUBSCRIBE); s.topics = e.constructor === Array ? e : [e], t.onSuccess && (s.callback = function () { t.onSuccess({ invocationContext: t.invocationContext }) }), t.timeout && (s.timeOut = new m(this, t.timeout, t.onFailure, [{ invocationContext: t.invocationContext, errorCode: r.UNSUBSCRIBE_TIMEOUT.code, errorMessage: a(r.UNSUBSCRIBE_TIMEOUT) }])), this._requires_ack(s), this._schedule_message(s) }, y.prototype.send = function (e) { this._trace("Client.send", e); var t = new d(n.PUBLISH); if (t.payloadMessage = e, this.connected) e.qos > 0 ? this._requires_ack(t) : this.onMessageDelivered && (this._notify_msg_sent[t] = this.onMessageDelivered(t.payloadMessage)), this._schedule_message(t); else { if (!this._reconnecting || !this.disconnectedPublishing) throw new Error(a(r.INVALID_STATE, ["not connected"])); if (Object.keys(this._sentMessages).length + this._buffered_msg_queue.length > this.disconnectedBufferSize) throw new Error(a(r.BUFFER_FULL, [this.disconnectedBufferSize])); e.qos > 0 ? this._requires_ack(t) : (t.sequence = ++this._sequence, this._buffered_msg_queue.unshift(t)) } }, y.prototype.disconnect = function () { if (this._trace("Client.disconnect"), this._reconnecting && (this._reconnectTimeout.cancel(), this._reconnectTimeout = null, this._reconnecting = !1), !this.socket) throw new Error(a(r.INVALID_STATE, ["not connecting or connected"])); var e = new d(n.DISCONNECT); this._notify_msg_sent[e] = o(this._disconnected, this), this._schedule_message(e) }, y.prototype.getTraceLog = function () { if (null !== this._traceBuffer) { this._trace("Client.getTraceLog", new Date), this._trace("Client.getTraceLog in flight messages", this._sentMessages.length); for (var e in this._sentMessages) this._trace("_sentMessages ", e, this._sentMessages[e]); for (var e in this._receivedMessages) this._trace("_receivedMessages ", e, this._receivedMessages[e]); return this._traceBuffer } }, y.prototype.startTrace = function () { null === this._traceBuffer && (this._traceBuffer = []), this._trace("Client.startTrace", new Date, "@VERSION@-@BUILDLEVEL@") }, y.prototype.stopTrace = function () { delete this._traceBuffer }, y.prototype._doConnect = function (e) { if (this.connectOptions.useSSL) { var t = e.split(":"); t[0] = "wss", e = t.join(":") } this._wsuri = e, this.connected = !1, this.connectOptions.mqttVersion < 4 ? this.socket = new WebSocket(e, ["mqttv3.1"]) : this.socket = new WebSocket(e, ["mqtt"]), this.socket.binaryType = "arraybuffer", this.socket.onopen = o(this._on_socket_open, this), this.socket.onmessage = o(this._on_socket_message, this), this.socket.onerror = o(this._on_socket_error, this), this.socket.onclose = o(this._on_socket_close, this), this.sendPinger = new v(this, this.connectOptions.keepAliveInterval), this.receivePinger = new v(this, this.connectOptions.keepAliveInterval), this._connectTimeout && (this._connectTimeout.cancel(), this._connectTimeout = null), this._connectTimeout = new m(this, this.connectOptions.timeout, this._disconnected, [r.CONNECT_TIMEOUT.code, a(r.CONNECT_TIMEOUT)]) }, y.prototype._schedule_message = function (e) { this._msg_queue.unshift(e), this.connected && this._process_queue() }, y.prototype.store = function (e, t) { var i = { type: t.type, messageIdentifier: t.messageIdentifier, version: 1 }; switch (t.type) { case n.PUBLISH: t.pubRecReceived && (i.pubRecReceived = !0), i.payloadMessage = {}; for (var o = "", c = t.payloadMessage.payloadBytes, h = 0; h < c.length; h++)c[h] <= 15 ? o = o + "0" + c[h].toString(16) : o += c[h].toString(16); i.payloadMessage.payloadHex = o, i.payloadMessage.qos = t.payloadMessage.qos, i.payloadMessage.destinationName = t.payloadMessage.destinationName, t.payloadMessage.duplicate && (i.payloadMessage.duplicate = !0), t.payloadMessage.retained && (i.payloadMessage.retained = !0), 0 === e.indexOf("Sent:") && (void 0 === t.sequence && (t.sequence = ++this._sequence), i.sequence = t.sequence); break; default: throw Error(a(r.INVALID_STORED_DATA, [e + this._localKey + t.messageIdentifier, i])) }s.setItem(e + this._localKey + t.messageIdentifier, JSON.stringify(i)) }, y.prototype.restore = function (e) { var t = s.getItem(e), i = JSON.parse(t), o = new d(i.type, i); switch (i.type) { case n.PUBLISH: for (var c = i.payloadMessage.payloadHex, h = new ArrayBuffer(c.length / 2), u = new Uint8Array(h), l = 0; c.length >= 2;) { var f = parseInt(c.substring(0, 2), 16); c = c.substring(2, c.length), u[l++] = f } var _ = new w(u); _.qos = i.payloadMessage.qos, _.destinationName = i.payloadMessage.destinationName, i.payloadMessage.duplicate && (_.duplicate = !0), i.payloadMessage.retained && (_.retained = !0), o.payloadMessage = _; break; default: throw Error(a(r.INVALID_STORED_DATA, [e, t])) }0 === e.indexOf("Sent:" + this._localKey) ? (o.payloadMessage.duplicate = !0, this._sentMessages[o.messageIdentifier] = o) : 0 === e.indexOf("Received:" + this._localKey) && (this._receivedMessages[o.messageIdentifier] = o) }, y.prototype._process_queue = function () { for (var e = null; e = this._msg_queue.pop();)this._socket_send(e), this._notify_msg_sent[e] && (this._notify_msg_sent[e](), delete this._notify_msg_sent[e]) }, y.prototype._requires_ack = function (e) { var t = Object.keys(this._sentMessages).length; if (t > this.maxMessageIdentifier) throw Error("Too many messages:" + t); for (; void 0 !== this._sentMessages[this._message_identifier];)this._message_identifier++; e.messageIdentifier = this._message_identifier, this._sentMessages[e.messageIdentifier] = e, e.type === n.PUBLISH && this.store("Sent:", e), this._message_identifier === this.maxMessageIdentifier && (this._message_identifier = 1) }, y.prototype._on_socket_open = function () { var e = new d(n.CONNECT, this.connectOptions); e.clientId = this.clientId, this._socket_send(e) }, y.prototype._on_socket_message = function (e) { this._trace("Client._on_socket_message", e.data); for (var t = this._deframeMessages(e.data), s = 0; s < t.length; s += 1)this._handleMessage(t[s]) }, y.prototype._deframeMessages = function (e) { var t = new Uint8Array(e), s = []; if (this.receiveBuffer) { var n = new Uint8Array(this.receiveBuffer.length + t.length); n.set(this.receiveBuffer), n.set(t, this.receiveBuffer.length), t = n, delete this.receiveBuffer } try { for (var i = 0; i < t.length;) { var o = l(t, i), c = o[0]; if (i = o[1], null === c) break; s.push(c) } i < t.length && (this.receiveBuffer = t.subarray(i)) } catch (e) { var h = "undefined" == e.hasOwnProperty("stack") ? e.stack.toString() : "No Error Stack Available"; return void this._disconnected(r.INTERNAL_ERROR.code, a(r.INTERNAL_ERROR, [e.message, h])) } return s }, y.prototype._handleMessage = function (e) { this._trace("Client._handleMessage", e); try { switch (e.type) { case n.CONNACK: if (this._connectTimeout.cancel(), this._reconnectTimeout && this._reconnectTimeout.cancel(), this.connectOptions.cleanSession) { for (var t in this._sentMessages) { var i = this._sentMessages[t]; s.removeItem("Sent:" + this._localKey + i.messageIdentifier) } this._sentMessages = {}; for (var t in this._receivedMessages) { var o = this._receivedMessages[t]; s.removeItem("Received:" + this._localKey + o.messageIdentifier) } this._receivedMessages = {} } if (0 !== e.returnCode) { this._disconnected(r.CONNACK_RETURNCODE.code, a(r.CONNACK_RETURNCODE, [e.returnCode, c[e.returnCode]])); break } this.connected = !0, this.connectOptions.uris && (this.hostIndex = this.connectOptions.uris.length); var h = []; for (var u in this._sentMessages) this._sentMessages.hasOwnProperty(u) && h.push(this._sentMessages[u]); if (this._buffered_msg_queue.length > 0) for (var l = null; l = this._buffered_msg_queue.pop();)h.push(l), this.onMessageDelivered && (this._notify_msg_sent[l] = this.onMessageDelivered(l.payloadMessage)); for (var f = 0, _ = (h = h.sort(function (e, t) { return e.sequence - t.sequence })).length; f < _; f++) { if ((i = h[f]).type == n.PUBLISH && i.pubRecReceived) { var g = new d(n.PUBREL, { messageIdentifier: i.messageIdentifier }); this._schedule_message(g) } else this._schedule_message(i) } this.connectOptions.onSuccess && this.connectOptions.onSuccess({ invocationContext: this.connectOptions.invocationContext }); var p = !1; this._reconnecting && (p = !0, this._reconnectInterval = 1, this._reconnecting = !1), this._connected(p, this._wsuri), this._process_queue(); break; case n.PUBLISH: this._receivePublish(e); break; case n.PUBACK: (i = this._sentMessages[e.messageIdentifier]) && (delete this._sentMessages[e.messageIdentifier], s.removeItem("Sent:" + this._localKey + e.messageIdentifier), this.onMessageDelivered && this.onMessageDelivered(i.payloadMessage)); break; case n.PUBREC: if (i = this._sentMessages[e.messageIdentifier]) { i.pubRecReceived = !0; g = new d(n.PUBREL, { messageIdentifier: e.messageIdentifier }); this.store("Sent:", i), this._schedule_message(g) } break; case n.PUBREL: o = this._receivedMessages[e.messageIdentifier]; s.removeItem("Received:" + this._localKey + e.messageIdentifier), o && (this._receiveMessage(o), delete this._receivedMessages[e.messageIdentifier]); var I = new d(n.PUBCOMP, { messageIdentifier: e.messageIdentifier }); this._schedule_message(I); break; case n.PUBCOMP: i = this._sentMessages[e.messageIdentifier]; delete this._sentMessages[e.messageIdentifier], s.removeItem("Sent:" + this._localKey + e.messageIdentifier), this.onMessageDelivered && this.onMessageDelivered(i.payloadMessage); break; case n.SUBACK: (i = this._sentMessages[e.messageIdentifier]) && (i.timeOut && i.timeOut.cancel(), 128 === e.returnCode[0] ? i.onFailure && i.onFailure(e.returnCode) : i.onSuccess && i.onSuccess(e.returnCode), delete this._sentMessages[e.messageIdentifier]); break; case n.UNSUBACK: (i = this._sentMessages[e.messageIdentifier]) && (i.timeOut && i.timeOut.cancel(), i.callback && i.callback(), delete this._sentMessages[e.messageIdentifier]); break; case n.PINGRESP: this.sendPinger.reset(); break; case n.DISCONNECT: this._disconnected(r.INVALID_MQTT_MESSAGE_TYPE.code, a(r.INVALID_MQTT_MESSAGE_TYPE, [e.type])); break; default: this._disconnected(r.INVALID_MQTT_MESSAGE_TYPE.code, a(r.INVALID_MQTT_MESSAGE_TYPE, [e.type])) } } catch (e) { var E = "undefined" == e.hasOwnProperty("stack") ? e.stack.toString() : "No Error Stack Available"; return void this._disconnected(r.INTERNAL_ERROR.code, a(r.INTERNAL_ERROR, [e.message, E])) } }, y.prototype._on_socket_error = function (e) { this._reconnecting || this._disconnected(r.SOCKET_ERROR.code, a(r.SOCKET_ERROR, [e.data])) }, y.prototype._on_socket_close = function () { this._reconnecting || this._disconnected(r.SOCKET_CLOSE.code, a(r.SOCKET_CLOSE)) }, y.prototype._socket_send = function (e) { if (1 == e.type) { var t = this._traceMask(e, "password"); this._trace("Client._socket_send", t) } else this._trace("Client._socket_send", e); this.socket.send(e.encode()), this.sendPinger.reset() }, y.prototype._receivePublish = function (e) { switch (e.payloadMessage.qos) { case "undefined": case 0: this._receiveMessage(e); break; case 1: var t = new d(n.PUBACK, { messageIdentifier: e.messageIdentifier }); this._schedule_message(t), this._receiveMessage(e); break; case 2: this._receivedMessages[e.messageIdentifier] = e, this.store("Received:", e); var s = new d(n.PUBREC, { messageIdentifier: e.messageIdentifier }); this._schedule_message(s); break; default: throw Error("Invaild qos=" + e.payloadMessage.qos) } }, y.prototype._receiveMessage = function (e) { this.onMessageArrived && this.onMessageArrived(e.payloadMessage) }, y.prototype._connected = function (e, t) { this.onConnected && this.onConnected(e, t) }, y.prototype._reconnect = function () { this._trace("Client._reconnect"), this.connected || (this._reconnecting = !0, this.sendPinger.cancel(), this.receivePinger.cancel(), this._reconnectInterval < 128 && (this._reconnectInterval = 2 * this._reconnectInterval), this.connectOptions.uris ? (this.hostIndex = 0, this._doConnect(this.connectOptions.uris[0])) : this._doConnect(this.uri)) }, y.prototype._disconnected = function (e, t) { if (this._trace("Client._disconnected", e, t), void 0 !== e && this._reconnecting) this._reconnectTimeout = new m(this, this._reconnectInterval, this._reconnect); else if (this.sendPinger.cancel(), this.receivePinger.cancel(), this._connectTimeout && (this._connectTimeout.cancel(), this._connectTimeout = null), this._msg_queue = [], this._buffered_msg_queue = [], this._notify_msg_sent = {}, this.socket && (this.socket.onopen = null, this.socket.onmessage = null, this.socket.onerror = null, this.socket.onclose = null, 1 === this.socket.readyState && this.socket.close(), delete this.socket), this.connectOptions.uris && this.hostIndex < this.connectOptions.uris.length - 1) this.hostIndex++ , this._doConnect(this.connectOptions.uris[this.hostIndex]); else if (void 0 === e && (e = r.OK.code, t = a(r.OK)), this.connected) { if (this.connected = !1, this.onConnectionLost && this.onConnectionLost({ errorCode: e, errorMessage: t, reconnect: this.connectOptions.reconnect, uri: this._wsuri }), e !== r.OK.code && this.connectOptions.reconnect) return this._reconnectInterval = 1, void this._reconnect() } else 4 === this.connectOptions.mqttVersion && !1 === this.connectOptions.mqttVersionExplicit ? (this._trace("Failed to connect V4, dropping back to V3"), this.connectOptions.mqttVersion = 3, this.connectOptions.uris ? (this.hostIndex = 0, this._doConnect(this.connectOptions.uris[0])) : this._doConnect(this.uri)) : this.connectOptions.onFailure && this.connectOptions.onFailure({ invocationContext: this.connectOptions.invocationContext, errorCode: e, errorMessage: t }) }, y.prototype._trace = function () { if (this.traceFunction) { var e = Array.prototype.slice.call(arguments); for (var t in e) void 0 !== e[t] && e.splice(t, 1, JSON.stringify(e[t])); var s = e.join(""); this.traceFunction({ severity: "Debug", message: s }) } if (null !== this._traceBuffer) { t = 0; for (var n = arguments.length; t < n; t++)this._traceBuffer.length == this._MAX_TRACE_ENTRIES && this._traceBuffer.shift(), 0 === t ? this._traceBuffer.push(arguments[t]) : void 0 === arguments[t] ? this._traceBuffer.push(arguments[t]) : this._traceBuffer.push("  " + JSON.stringify(arguments[t])) } }, y.prototype._traceMask = function (e, t) { var s = {}; for (var n in e) e.hasOwnProperty(n) && (s[n] = n == t ? "******" : e[n]); return s }; var w = function (e) { var t, s; if (!("string" == typeof e || e instanceof ArrayBuffer || ArrayBuffer.isView(e) && !(e instanceof DataView))) throw a(r.INVALID_ARGUMENT, [e, "newPayload"]); t = e; var n = 0, i = !1, o = !1; Object.defineProperties(this, { payloadString: { enumerable: !0, get: function () { return "string" == typeof t ? t : E(t, 0, t.length) } }, payloadBytes: { enumerable: !0, get: function () { if ("string" == typeof t) { var e = new ArrayBuffer(p(t)), s = new Uint8Array(e); return I(t, s, 0), s } return t } }, destinationName: { enumerable: !0, get: function () { return s }, set: function (e) { if ("string" != typeof e) throw new Error(a(r.INVALID_ARGUMENT, [e, "newDestinationName"])); s = e } }, qos: { enumerable: !0, get: function () { return n }, set: function (e) { if (0 !== e && 1 !== e && 2 !== e) throw new Error("Invalid argument:" + e); n = e } }, retained: { enumerable: !0, get: function () { return i }, set: function (e) { if ("boolean" != typeof e) throw new Error(a(r.INVALID_ARGUMENT, [e, "newRetained"])); i = e } }, topic: { enumerable: !0, get: function () { return s }, set: function (e) { s = e } }, duplicate: { enumerable: !0, get: function () { return o }, set: function (e) { o = e } } }) }; return { Client: function (e, t, s, n) { var o; if ("string" != typeof e) throw new Error(a(r.INVALID_TYPE, [typeof e, "host"])); if (2 == arguments.length) { n = t; var c = (o = e).match(/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/); if (!c) throw new Error(a(r.INVALID_ARGUMENT, [e, "host"])); e = c[4] || c[2], t = parseInt(c[7]), s = c[8] } else { if (3 == arguments.length && (n = s, s = "/mqtt"), "number" != typeof t || t < 0) throw new Error(a(r.INVALID_TYPE, [typeof t, "port"])); if ("string" != typeof s) throw new Error(a(r.INVALID_TYPE, [typeof s, "path"])); var h = -1 !== e.indexOf(":") && "[" !== e.slice(0, 1) && "]" !== e.slice(-1); o = "ws://" + (h ? "[" + e + "]" : e) + ":" + t + s } for (var u = 0, d = 0; d < n.length; d++) { var l = n.charCodeAt(d); 55296 <= l && l <= 56319 && d++ , u++ } if ("string" != typeof n || u > 65535) throw new Error(a(r.INVALID_ARGUMENT, [n, "clientId"])); var f = new y(o, e, t, s, n); Object.defineProperties(this, { host: { get: function () { return e }, set: function () { throw new Error(a(r.UNSUPPORTED_OPERATION)) } }, port: { get: function () { return t }, set: function () { throw new Error(a(r.UNSUPPORTED_OPERATION)) } }, path: { get: function () { return s }, set: function () { throw new Error(a(r.UNSUPPORTED_OPERATION)) } }, uri: { get: function () { return o }, set: function () { throw new Error(a(r.UNSUPPORTED_OPERATION)) } }, clientId: { get: function () { return f.clientId }, set: function () { throw new Error(a(r.UNSUPPORTED_OPERATION)) } }, onConnected: { get: function () { return f.onConnected }, set: function (e) { if ("function" != typeof e) throw new Error(a(r.INVALID_TYPE, [typeof e, "onConnected"])); f.onConnected = e } }, disconnectedPublishing: { get: function () { return f.disconnectedPublishing }, set: function (e) { f.disconnectedPublishing = e } }, disconnectedBufferSize: { get: function () { return f.disconnectedBufferSize }, set: function (e) { f.disconnectedBufferSize = e } }, onConnectionLost: { get: function () { return f.onConnectionLost }, set: function (e) { if ("function" != typeof e) throw new Error(a(r.INVALID_TYPE, [typeof e, "onConnectionLost"])); f.onConnectionLost = e } }, onMessageDelivered: { get: function () { return f.onMessageDelivered }, set: function (e) { if ("function" != typeof e) throw new Error(a(r.INVALID_TYPE, [typeof e, "onMessageDelivered"])); f.onMessageDelivered = e } }, onMessageArrived: { get: function () { return f.onMessageArrived }, set: function (e) { if ("function" != typeof e) throw new Error(a(r.INVALID_TYPE, [typeof e, "onMessageArrived"])); f.onMessageArrived = e } }, trace: { get: function () { return f.traceFunction }, set: function (e) { if ("function" != typeof e) throw new Error(a(r.INVALID_TYPE, [typeof e, "onTrace"])); f.traceFunction = e } } }), this.connect = function (e) { if (i(e = e || {}, { timeout: "number", userName: "string", password: "string", willMessage: "object", keepAliveInterval: "number", cleanSession: "boolean", useSSL: "boolean", invocationContext: "object", onSuccess: "function", onFailure: "function", hosts: "object", ports: "object", reconnect: "boolean", mqttVersion: "number", mqttVersionExplicit: "boolean", uris: "object" }), void 0 === e.keepAliveInterval && (e.keepAliveInterval = 60), e.mqttVersion > 4 || e.mqttVersion < 3) throw new Error(a(r.INVALID_ARGUMENT, [e.mqttVersion, "connectOptions.mqttVersion"])); if (void 0 === e.mqttVersion ? (e.mqttVersionExplicit = !1, e.mqttVersion = 4) : e.mqttVersionExplicit = !0, void 0 !== e.password && void 0 === e.userName) throw new Error(a(r.INVALID_ARGUMENT, [e.password, "connectOptions.password"])); if (e.willMessage) { if (!(e.willMessage instanceof w)) throw new Error(a(r.INVALID_TYPE, [e.willMessage, "connectOptions.willMessage"])); if (e.willMessage.stringPayload = null, void 0 === e.willMessage.destinationName) throw new Error(a(r.INVALID_TYPE, [typeof e.willMessage.destinationName, "connectOptions.willMessage.destinationName"])) } if (void 0 === e.cleanSession && (e.cleanSession = !0), e.hosts) { if (!(e.hosts instanceof Array)) throw new Error(a(r.INVALID_ARGUMENT, [e.hosts, "connectOptions.hosts"])); if (e.hosts.length < 1) throw new Error(a(r.INVALID_ARGUMENT, [e.hosts, "connectOptions.hosts"])); for (var t = !1, n = 0; n < e.hosts.length; n++) { if ("string" != typeof e.hosts[n]) throw new Error(a(r.INVALID_TYPE, [typeof e.hosts[n], "connectOptions.hosts[" + n + "]"])); if (/^(wss?):\/\/((\[(.+)\])|([^\/]+?))(:(\d+))?(\/.*)$/.test(e.hosts[n])) { if (0 === n) t = !0; else if (!t) throw new Error(a(r.INVALID_ARGUMENT, [e.hosts[n], "connectOptions.hosts[" + n + "]"])) } else if (t) throw new Error(a(r.INVALID_ARGUMENT, [e.hosts[n], "connectOptions.hosts[" + n + "]"])) } if (t) e.uris = e.hosts; else { if (!e.ports) throw new Error(a(r.INVALID_ARGUMENT, [e.ports, "connectOptions.ports"])); if (!(e.ports instanceof Array)) throw new Error(a(r.INVALID_ARGUMENT, [e.ports, "connectOptions.ports"])); if (e.hosts.length !== e.ports.length) throw new Error(a(r.INVALID_ARGUMENT, [e.ports, "connectOptions.ports"])); for (e.uris = [], n = 0; n < e.hosts.length; n++) { if ("number" != typeof e.ports[n] || e.ports[n] < 0) throw new Error(a(r.INVALID_TYPE, [typeof e.ports[n], "connectOptions.ports[" + n + "]"])); var c = e.hosts[n], h = e.ports[n], u = -1 !== c.indexOf(":"); o = "ws://" + (u ? "[" + c + "]" : c) + ":" + h + s, e.uris.push(o) } } } f.connect(e) }, this.subscribe = function (e, t) { if ("string" != typeof e && e.constructor !== Array) throw new Error("Invalid argument:" + e); if (i(t = t || {}, { qos: "number", invocationContext: "object", onSuccess: "function", onFailure: "function", timeout: "number" }), t.timeout && !t.onFailure) throw new Error("subscribeOptions.timeout specified with no onFailure callback."); if (void 0 !== t.qos && 0 !== t.qos && 1 !== t.qos && 2 !== t.qos) throw new Error(a(r.INVALID_ARGUMENT, [t.qos, "subscribeOptions.qos"])); f.subscribe(e, t) }, this.unsubscribe = function (e, t) { if ("string" != typeof e && e.constructor !== Array) throw new Error("Invalid argument:" + e); if (i(t = t || {}, { invocationContext: "object", onSuccess: "function", onFailure: "function", timeout: "number" }), t.timeout && !t.onFailure) throw new Error("unsubscribeOptions.timeout specified with no onFailure callback."); f.unsubscribe(e, t) }, this.send = function (e, t, s, n) { var i; if (0 === arguments.length) throw new Error("Invalid argument.length"); if (1 == arguments.length) { if (!(e instanceof w) && "string" != typeof e) throw new Error("Invalid argument:" + typeof e); if (void 0 === (i = e).destinationName) throw new Error(a(r.INVALID_ARGUMENT, [i.destinationName, "Message.destinationName"])); f.send(i) } else (i = new w(t)).destinationName = e, arguments.length >= 3 && (i.qos = s), arguments.length >= 4 && (i.retained = n), f.send(i) }, this.publish = function (e, t, s, n) { var i; if (0 === arguments.length) throw new Error("Invalid argument.length"); if (1 == arguments.length) { if (!(e instanceof w) && "string" != typeof e) throw new Error("Invalid argument:" + typeof e); if (void 0 === (i = e).destinationName) throw new Error(a(r.INVALID_ARGUMENT, [i.destinationName, "Message.destinationName"])); f.send(i) } else (i = new w(t)).destinationName = e, arguments.length >= 3 && (i.qos = s), arguments.length >= 4 && (i.retained = n), f.send(i) }, this.disconnect = function () { f.disconnect() }, this.getTraceLog = function () { return f.getTraceLog() }, this.startTrace = function () { f.startTrace() }, this.stopTrace = function () { f.stopTrace() }, this.isConnected = function () { return f.connected } }, Message: w } }("undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}) });